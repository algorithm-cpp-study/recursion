**재귀** - 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

우리가 어떤 문제를 재귀로 해결하겠다는 것은 귀납적인 방식으로 문제를 해결하겠다는 뜻이고 이 방식은 상식과는 큰 차이가 있다. 귀납적인 방식으로 생각하기 위해서는 정차지향적 사고를 탈피해야 한다.

```
void func1(int n){
    if(n == 0) return;
    cout << n << ' ';
    func1(n-1);
}
```

func1(5)가 호출되었을때 절차지향적 사고로 위 코드를 풀이한다면 func1(5)가 func1(4)를 호출하고 func1(4)가 func1(3)을 호출하는 과정을 반복하는 끝에 func1(0)가 호출되었을때 종료되며 5 4 3 2 1 이 출력 된다는 것을 알수있다.

이 문제를 귀납적 사고방식으로 생각해본다면 func1(1)이 1을 출력하고 만약 func1(k)를 호출한다면 k k-1 k-2 ... 1이 출력된다고 생각할 수 있다. 그렇기 때문에 func1(k+1) 을 호출한다면 k+1 k k-1 ... 1이 차례로 출력한다. 그렇다면 func1은 n 부터 1까지 차례로 출력하는 함수임을 알수 있게된다.

**재귀 함수의 조건**

-    재귀 함수는 특정한 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 하며, 이를 **Base Condition** 이라고 한다.
-   그리고 모든 입력은 반드시 base condition으로 수렴해야 한다.
-   이 두 조건을 충족하지 못하면 재귀 함수는 runtime error를 발생시키게 될것이다.

그렇기 때문에 재귀 함수를 작성할때는 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 알고 있어야 한다. 그리고 모든 재귀 함수는 반복문으로 동일한 동작을 하는 함수를 구현할 수 있으며, 재귀는 반복문에 비해 코드가 간결하지만 메모리/시간에서 많은 손해를 본다.

```
int fibo(int n){
    if (n <= 1) return 1;
    return fibo(n-1) + fibo(n-2);
}
```

위 코드는 피보나치 수열을 반환하는 함수이다. 위 코드의 실행과정을 visualize 해보면 아래와 같다.

[##_Image|kage@tzZ2F/btr7Hh8LUVT/XCHmcwUCkNURQJhMJJu8Q0/img.png|CDM|1.3|{"originWidth":674,"originHeight":314,"style":"alignCenter"}_##]

이 재귀 함수의 시간복잡도는 O(1.618^n)이며, 그 말은 n이 100 정도만 되어도 일반 컴퓨터로 20000년 넘게 걸린다는 뜻이다. 이런 일이 벌어지는 이유는 이미 계산한걸 또 계산하는 일이 벌어지기 때문이다. 그렇기 때문에 이런 문제의 경우 재귀 대신 다이나믹 프로그래밍을 사용해서 풀게되면 O(n)의 시간복잡도로 해결하는 것이 가능하다. 

또한 재귀 함수는 메모리적으로도 손해를 많이 보게 되는데, 이는 재귀 함수가 자기 자신을 부를 때 스택 영역에 함수에 대한 정보가 누적되기 때문이다. 

참조 : [https://blog.encrypted.gg/943](https://blog.encrypted.gg/943)